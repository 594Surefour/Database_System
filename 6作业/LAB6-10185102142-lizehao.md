## <center>作业6-10185102142-李泽浩



##### (1)编写函数func_rand_ID，可随机生成长度为18位的仿身份证号码，第1-6位为0-9之间的数字，第7-14位为19600101到20200101之间的某个有效日期，第15-17位为0-9之间的数字，第18位为0-9之间的数字或大写X。

```sql
DROP FUNCTION IF EXISTS func_rand_ID;

CREATE FUNCTION func_rand_ID() RETURNS VARCHAR(30)
READS SQL DATA
BEGIN
	DECLARE result VARCHAR(18) DEFAULT '';
	DECLARE first_num VARCHAR(6) DEFAULT '';
	DECLARE birthday VARCHAR(10) DEFAULT '';
	DECLARE second_num VARCHAR(3) DEFAULT '';
	DECLARE last_num VARCHAR(1) DEFAULT '';
	DECLARE charset VARCHAR(11) DEFAULT '';
	DECLARE interday INT DEFAULT 0;
	DECLARE numset varchar(10) DEFAULT '';
	DECLARE i INT DEFAULT 0;
	DECLARE j INT DEFAULT 0;

	SET numset = "0123456789";
	SET charset = "0123456789X";

	#处理1-6位置上
	WHILE i<6 DO
		SET first_num = CONCAT(first_num, substring(numset,FLOOR(1+RAND()*10),1));
		SET i = i + 1;
	END while;
	#SET first_num = rand()*100000;
	
	#处理生日
	SET interday = floor(RAND()*21915);#时间间隔
	SET birthday = DATE_ADD("1960-01-01",INTERVAL interday day);
	SELECT REPLACE(birthday,'-','') INTO birthday;#去除横线
	
	#处理15-17位置上
	WHILE j<3 DO
		SET second_num = CONCAT(second_num,substring(numset,FLOOR(1+RAND()*10),1));
		SET j = j + 1;
	END while;
	#SET second_num = floor(RAND()*100);

	#处理最后一位
	SET last_num = substring(charset,FLOOR(1+RAND()*11),1);
	
	#合并结果
	SET result = CONCAT(result, first_num, birthday, second_num, last_num);

	RETURN result;
END;

SELECT func_rand_ID();
```

随机生成两个身份证号如下：

<img src="LAB5-10185102142-的副本.assets/截屏2021-04-26 下午6.40.03.png" alt="截屏2021-04-26 下午6.40.03" style="zoom:33%;" />

<img src="LAB5-10185102142-的副本.assets/截屏2021-04-26 下午6.40.18.png" alt="截屏2021-04-26 下午6.40.18" style="zoom:33%;" />



##### （2）使用下面的语句新建一张测试表testUser，编写存储过程createTestCases，往testUser表中插入100条测试数据，其中username是随机生成的长度为8的字符串（符号可包括a-z、A-Z、0-9），email由函数func_rand_email生成，telephone由函数func_rand_telnum生成，ucode由函数func_rand_ID生成。

```sql
DROP PROCEDURE IF EXISTS createTestCases;

CREATE PROCEDURE createTestCases ()
BEGIN
	DECLARE i INT DEFAULT 0;
	DECLARE id INT DEFAULT 0;
	DECLARE cnt INT DEFAULT 0;
	DECLARE name VARCHAR(8) DEFAULT '';
	DECLARE mail VARCHAR(75) DEFAULT '';
	DECLARE phone VARCHAR(11) DEFAULT '';
	DECLARE code VARCHAR(30) DEFAULT '';
	DECLARE charset VARCHAR(70); 
	
	SET charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; 

	WHILE cnt < 100 DO
		SET name = '';
		SET i = 0;
		SELECT cnt INTO id;#uid
		SELECT func_rand_email() into mail;#email
		SELECT func_rand_telnum() into phone;#telephone
		SELECT func_rand_ID() into code;#ucode
		#生成username
		WHILE i<8 DO    
			SET name = concat(name,substring(charset,floor(1+RAND()*62),1));    
			SET i=i+1;  
		END WHILE;
		INSERT INTO testuser VALUES (id,name,mail,phone,code);
		
		SET cnt = cnt + 1;
	END WHILE;
	
END;

CALL createTestCases();
```

<img src="LAB5-10185102142-的副本.assets/截屏2021-04-26 下午7.04.59.png" alt="截屏2021-04-26 下午7.04.59" style="zoom:33%;" />

<img src="LAB5-10185102142-的副本.assets/截屏2021-04-26 下午7.06.39.png" alt="截屏2021-04-26 下午7.06.39" style="zoom:33%;" />



##### （3）在employee表中有引用EMP_ID字段的SUPERIOR_EMP_ID字段，代表上级领导编号，行长没有上级领导，因此其SUPERIOR_EMP_ID的值为NULL，其余员工的SUPERIOR_EMP_ID值均不为NULL。创建存储过程getEmpStructure，在employee表上利用递归CTE实现员工层级的计算，行长层级为1，副行长为2，依此类推，该存储过程输出员工编号（EMP_ID）、员工姓名（LAST_NAME和FIRST_NAME拼接）、层级（命名为LEVEL）、职位名称（TITLE）。

```sql
#非procedure方法
WITH RECURSIVE employee_level AS(
		SELECT EMP_ID, CONCAT(LAST_NAME, FIRST_NAME) as fname, 1 lvl, TITLE
		FROM employee
		WHERE SUPERIOR_EMP_ID IS NULL
			UNION ALL
		SELECT e.EMP_ID, CONCAT(e.LAST_NAME,e.FIRST_NAME) as fname,  lvl+1, e.TITLE
		FROM employee as e	INNER JOIN employee_level as el on e.SUPERIOR_EMP_ID = el.EMP_ID
	)
	SELECT emp_id, fname, lvl, e.title
	FROM employee_level as el INNER JOIN employee as e USING(EMP_ID)
	ORDER BY lvl;
```

```sql
#procedure方法
DROP PROCEDURE IF EXISTS getEmpStructure;

CREATE PROCEDURE getEmpStructure()
BEGIN
	DECLARE id VARCHAR(2) DEFAULT '';
	DECLARE full_name VARCHAR(30) DEFAULT '';
	DECLARE LEVEL INT DEFAULT 0;
	DECLARE title varchar(40) DEFAULT '';
	#DECLARE fname VARCHAR(30) DEFAULT '';
	
	WITH RECURSIVE employee_level AS(
		SELECT EMP_ID, CONCAT(FIRST_NAME,LAST_NAME) as fname, 1 lvl, TITLE
		FROM employee
		WHERE SUPERIOR_EMP_ID IS NULL
			UNION ALL
		SELECT e.EMP_ID, CONCAT(e.FIRST_NAME,e.LAST_NAME) as fname,  lvl+1, e.TITLE
		FROM employee as e	INNER JOIN employee_level as el on e.SUPERIOR_EMP_ID = el.EMP_ID
	)
	
	SELECT EMP_ID INTO id, fname INTO full_name, lvl INTO LEVEL, e.TITLE INTO title
	FROM employee_level as el INNER JOIN employee as e USING(EMP_ID);
	
END;

CALL getEmpStructure();
```

<img src="LAB6-10185102142-lizehao.assets/截屏2021-04-27 上午10.37.34.png" alt="截屏2021-04-27 上午10.37.34" style="zoom:50%;" />







##### （4）创建存储过程updateCloseDate，该存储过程更新account表中的关闭日期（CLOSE_DATE），根据产品编号做不同的更新操作，要求使用游标：

a.对产品编号对应类型为存款的账户（即产品编号PRODUCT_CD对应PRODUCT_TYPE_CD为ACCOUNT），如开户日期（OPEN_DATE）在2015-01-01之前（含）的，设置其关闭日期（CLOSE_DATE）为开户日期加20年，否则为开户日期加30年；

b.对产品编号对应类型为贷款的账户（即产品编号PRODUCT_CD对应PRODUCT_TYPE_CD为LOAN），如可用余额（AVAIL_BALANCE）少于100000的（含），设置其关闭日期（CLOSE_DATE）为开户日期加20年，否则为开户日期加30年；

c.对产品编号对应类型为保险的账户（即产品编号PRODUCT_CD对应PRODUCT_TYPE_CD为INSURANCE），设置其关闭日期（CLOSE_DATE）为开户日期加15年。

```sql
DROP PROCEDURE IF EXISTS updateCloseDate;

CREATE PROCEDURE updateCloseDate()
BEGIN
	DECLARE new_date DATE DEFAULT '';
	
	DECLARE cursor_update CURSOR
		SELECT 
			(CASE 
				WHEN p.product_TYPE_CD = "ACCOUNT" AND OPEN_DATE <= "2015-01-01"
					THEN DATE_ADD(OPEN_DATE,INTERVAL 20 year)
				WHEN p.PRODUCT_TYPE_CD = "ACCOUNT" AND OPEN_DATE > "2015-01-01"
					THEN DATE_ADD(OPEN_DATE,INTERVAL 30 year)
				WHEN p.PRODUCT_TYPE_CD = "LOAN" AND AVAIL_BALANCE <= 100000 
					THEN DATE_ADD(OPEN_DATE,INTERVAL 20 year)
				WHEN p.PRODUCT_TYPE_CD = "LOAN" AND AVAIL_BALANCE > 100000 
					THEN DATE_ADD(OPEN_DATE,INTERVAL 30 year)
				WHEN p.PRODUCT_TYPE_CD = "INSURANCE"  
					THEN DATE_ADD(OPEN_DATE,INTERVAL 15 year)
			END ) as ndate
		FROM account as a INNER JOIN product as p on a.PRODUCT_CD = p.PRODUCT_CD;

	open cursor_update;
	FETCH cursor_update INTO new_date;
	UPDATE employee SET 'CLOSE_DATE' = new_date;
	CLOSE cursor_update;
	
END;

CALL updateCloseDate();
```



##### （5）在acc_transaction上定义触发器t_newTransaction，当往acc_transaction中插入一条数据时，依据账户编号（ACCOUNT_ID）更新account表中对应账户的可用余额（AVAIL_BALANCE）和最后活跃日期（LAST_ACTIVITY_DATE）：

a.如果插入数据的交易类型编码（TXN_TYPE_CD）为CD、TT、IC、LI则设置可用余额为当前可用余额加上交易金额、最后活跃日期为当前日期

b.如果插入数据的交易类型编码（TXN_TYPE_CD）为CW、TF则设置可用余额为当前可用余额减去交易金额、最后活跃日期为当前日期；如当前可用余额减去交易金额小于0，则撤销对acc_transaction此条数据的插入，同时输出提示“余额不足Insufficient Balance”。

```sql

```



##### （6）使用下面的语句创建一张表officer_temp。在officer上定义触发器t_insertOfficer，当往officer中新插入一条单位联系人信息时候，检查对应的客户编号（CUST_ID）字段，如该客户编号对应的单位联系人信息在officer表中已存在，往officer_temp中插入一条数据，内容为：原有联系人编号（OFFICER_ID）、当前新联系人的START_DATE；如该客户编号对应的单位联系人信息不存在则直接插入。

```sql

```





